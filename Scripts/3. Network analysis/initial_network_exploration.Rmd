

# Set up

Import packages
```{r}
suppressPackageStartupMessages({
  suppressWarnings({
  library(tidyverse)   # Data wrangling
  library(here)        # File management
  library(readxl)      # Read excel files
  library(igraph)      # Network analysis
  library(GGally)      # Exploratory scatter plots
  library(psych)       # Summary stats
  library(factoextra)  # K-means
  library(tmap)        # Map
  library(sf)          # Spatial analysis
  })})
```

Set settings and universal variables
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here())
```

# Import data

## Network data
Our cleaned and processed network data generated into an igraph object
```{r}
load("data for upload/20251218_network_igraph.Rdata")

network_df = read.csv("Data/Outputs/20251215_network_joined.csv")
``` 

```{r}
V(network)$color <- ifelse(V(network)$type == "source", "dodgerblue3","coral2")

plot(network, 
     layout = layout.kamada.kawai(network), 
     vertex.label = NA, 
     vertex.size = 5, 
     #vertex.colour = "type", 
     vertex.frame.colour = "black", 
     edge.arrow.size = .3, 
     edge.wdith = 1.5)

```


## Drought vulnerability

DWR small system vulnerability data for validation, hosted on [this page](https://water.ca.gov/Programs/Water-Use-And-Efficiency/SB-552/SB-552-Tool) and downloaded as a csv from [this link](https://data.cnra.ca.gov/dataset/i07-water-shortage-vulnerability-small-water-systems).

More information on documentation and methodology is available [here](https://data.cnra.ca.gov/dataset/water-shortage-vulnerability-technical-methods/resource/090baaf3-dc47-4e21-8eba-d9bf499a76a0)
```{r, eval = F}
dwr_vulnerability1 = read.csv("Data/Source/Small System Drought Vulnerability/i07_Water_Shortage_Vulnerability_Small_Water_Systems.csv")%>%
  select(SABL_PWSID, SC5e_Drought_Impact)%>%
  rename(pwsid = 1, sb552_drought_vulnerable = 2)%>%
  mutate(sb552_drought_vulnerable = ifelse(grepl("Listed as having", sb552_drought_vulnerable), 1, 0))%>%
  filter(pwsid %in% all_nodes$id & sb552_drought_vulnerable == 1)
```

To get more comprehensive drought vulnerability data, we also add to this list a dataset of drought-vulnerable public water systems compiled by the Pacific Institute as part of [this](https://pacinst.org/wp-content/uploads/2017/01/PI_DroughtAndEquityInCA_Jan_2017.pdf) 2017 report. The data sources are also listed [here](https://pacinst.org/wp-content/uploads/2017/01/PI_DroughtAndEquityInCA-2017_Appendix1A_3.pdf). 
```{r}
pacific_vulnerability = read.csv("Data/Source/Small System Drought Vulnerability/Appendix-1B-Drought-Impacted-Public-Water-Systems.xlsx - DroughtImpactedPWS.csv")%>%
  rename(pwsid = PWSID)%>%
  select(pwsid)%>%
  filter(pwsid != "")%>%
  mutate(pacific_drought_vulnerable = 1)
```


Data provided by DWR to Kristin and sent via email on Jan 16, 2026
```{r}
dwr_vulnerability = read_excel("Data/Source/Small System Drought Vulnerability/Compiled DWR PRA impacted systems.xlsx")%>%
  rename(system_name = 1)%>%
  unique()%>%
  mutate(
    pwsid = case_when(
      grepl("Banning Heights", system_name) ~ "CA3301031",
      grepl("Bolinas", system_name) ~ "CA2110005",
      grepl("Brooktrails", system_name) ~ "CA2310009",
      grepl("Burnt", system_name) ~ "CA5304109",
      grepl("Cachuma", system_name) ~ "CA4210028",
      grepl("Camptonville", system_name) ~ "CA5800924",
      grepl("Casitas", system_name) ~ "CA5601104",
      grepl("Chemeketa", system_name) ~ "CA4300517",
      grepl("Bragg", system_name) ~ "CA2310001",
      grepl("Huron", system_name) ~ "CA1010044",
      grepl("City of Lakeport", system_name) ~ "CA1710004",
      grepl("Orange Cove", system_name) ~ "CA1010023",
      grepl("Trinidad", system_name) ~ "CA1210018",
      grepl("Ukiah", system_name) ~ "CA2310003",
      grepl("Westmorland", system_name) ~ "CA1310008",
      grepl("Clearlake", system_name) ~ "CA1710001",
      grepl("Colonial Heights", system_name) ~ "CA3910002",
      grepl("Lincoln Village", system_name) ~ "CA3910010",
      grepl("Davenport", system_name) ~ "CA4400571",
      grepl("El Toro", system_name) ~ "CA3010079",
      grepl("Elk Creek", system_name) ~ "CA1100616",
      grepl("18", system_name) ~ "CA1010051",
      grepl("Groveland", system_name) ~ "CA5510009",
      grepl("Garberville", system_name) ~ "CA1210008",
      grepl("Harbor", system_name) ~ "CA1700568",
      grepl("Inverness", system_name) ~ "CA2110001",
      grepl("Irish", system_name) ~ "CA2310012",
      grepl("Kettleman", system_name) ~ "CA1610009",
      grepl("Konocti County", system_name) ~ "CA1710006",
      grepl("La Cumbre", system_name) ~ "CA4210024",
      grepl("North Marin", system_name) ~ "CA2110003",
      grepl("Redwood Valley", system_name) ~ "CA2310008",
      grepl("Springville", system_name) ~ "CA5410011",
      grepl("Spring Valley Lake", system_name) ~ "CA1710018",
      grepl("Lakeport", system_name) ~ "CA1710021",
      grepl("Don Pedro", system_name) ~ "CA5510008",
      grepl("Loma Mar", system_name) ~ "CA4100512",
      grepl("Hidden Lakes", system_name) ~ "CA2000544",
      grepl("Marygold", system_name) ~ "CA3610028",
      grepl("Mount Konocti", system_name) ~ "CA1710014",
      grepl("Mountain Gate", system_name) ~ "CA4510002",
      grepl("Oceano", system_name) ~ "CA4010005",
      grepl("Redway", system_name) ~ "CA1210011",
      grepl("Rubio", system_name) ~ "CA1910140",
      grepl("San Lorenzo", system_name) ~ "CA4410014",
      grepl("Senior Canyon", system_name) ~ "CA5601117",
      grepl("Sugarloaf", system_name) ~ "CA4500006",
      grepl("Jones Valley", system_name) ~ "CA4510004",
      grepl("Sierraville", system_name) ~ "CA4600018",
      grepl("Stinson", system_name) ~ "CA2110004",
      grepl("Tuolu", system_name) ~ "CA5510003",
      grepl("Westhaven", system_name) ~ "CA1210024"))%>%
  filter(!is.na(pwsid))%>%
  select(-system_name)%>%
  mutate(dwr_drought_vulnerable = 1)
```


```{r}
swrcb_vulnerability = read_excel("Data/Source/Small System Drought Vulnerability/Filtered SWRCB PRA data.xlsx")%>%
  select(PWS)%>%
  rename(pwsid = 1)%>%
  mutate(pwsid = paste("CA", pwsid, sep = ""),
         swrcb_drought_vulnerable = 1)%>%
  filter(pwsid %in% all_nodes$id)
```


Now we can combine the three. We'll consider a system drought vulnerable if it appears in any of the vulnerability datasets. 
```{r}
comb_vulnerability = full_join(dwr_vulnerability, swrcb_vulnerability, by = "pwsid")%>%
  full_join(., pacific_vulnerability, by = "pwsid")%>%
  mutate(across(where(is.numeric), ~replace_na(.x, 0)),
         any_drought_vulnerable = 1)%>%
  unique()

rm(dwr_vulnerability, swrcb_vulnerability, pacific_vulnerability)
```

# Calculating Metrics

## Centrality

Calculate in, out, and total degree centrality for systems. Compile into one 'master' dataframe with system centralities 
```{r}
system_centrality = all_nodes%>%
  filter(type == "system")%>%
  rename(in_degree = num_sw_sources,
         out_degree = num_systems_served,
         pwsid = id)%>%
  mutate(
    out_degree = replace_na(out_degree, 0),
    total_degree = in_degree + out_degree)%>%
  arrange(-total_degree)%>%
  select(pwsid, in_degree, out_degree, total_degree)
```

Calculate betweenness centrality - systems that are major redistribution hubs (ie: measure of centrality based on shortest paths that pass through a given node). Add to master dataframe.
```{r}
betweenness_all = betweenness(network, directed = TRUE)
system_centrality$betweenness = betweenness_all[V(network)$type == "system"]

rm(betweenness_all)
```

Out degree centrality for sources
```{r}
source_centrality = all_nodes%>%
  rename(source_name = id, out_degree = num_systems_served)%>%
  filter(type == "source")%>%
  arrange(-out_degree)%>%
  select(1:3)
```

## Path length

Calculate shortest paths from sources to systems
```{r}
sources = V(network)[type == "source"]
systems = V(network)[type == "system"]

# Get shortest paths between all sources to all systems
path_length_matrix = distances(network, v = sources, to = systems, mode = "out")
#path_lengths = as.vector(path_length_matrix[is.finite(as.vector(path_length_matrix))])

# Get shortest paths between all systems (for reachable systems calculation)
system_to_system_matrix = distances(network, v = systems, to = systems, mode = "out")
```

Summary stats for sources' path lengths
```{r}
source_path_lengths = data.frame(
  source_name = sources$name,
  n_reachable_systems = apply(path_length_matrix, 1, function(x) sum(is.finite(x))))
```

Summary stats for systems' path lengths

Right now, this is ONLY when systems are the final node on a path
```{r}
system_path_lengths = data.frame(
  pwsid = systems$name,
  mean_path_length = apply(path_length_matrix, 2, function(x) mean(x[is.finite(x)])),
  median_path_length = apply(path_length_matrix, 2, function(x) median(x[is.finite(x)])),
  max_path_length = apply(path_length_matrix, 2, function(x) max(x[is.finite(x)])),
  min_path_length = apply(path_length_matrix, 2, function(x) min(x[is.finite(x)])),
  n_reachable_sources = apply(path_length_matrix, 2, function(x) sum(is.finite(x))),
  n_reachable_systems = apply(system_to_system_matrix, 1, function(x) sum(is.finite(x)) - 1)) %>%  # Subtract 1 to exclude self
  arrange(-max_path_length)

rm(path_length_matrix, system_to_system_matrix)
```

## Source diversity

```{r}
# Calculate GW percentage for each system
gw_rows = network_df %>%
  group_by(pwsid) %>%
  reframe(
    source_name = "gw", 
    source_type = "gw",
    average_source_usage = 100 - sum(average_source_usage)) %>%
  filter(average_source_usage > 0)

# Combine with original data
diversity_df = bind_rows(network_df, gw_rows)%>%
  arrange(pwsid, source_name)%>%
  group_by(pwsid)%>%
  reframe(hhi = sum(average_source_usage^2))

rm(gw_rows, systems, sources)
```

Kristin also mentioned [participation coefficient](https://www.google.com/url?q=https://www.nature.com/articles/s41467-017-01189-w%23:~:text%3DParticipation%2520coefficient,-Given%2520a%2520particular%26text%3Dwhere%2520%257BK_i%257D%2520is%2520the%2520sum,are%2520to%2520a%2520single%2520community&sa=D&source=docs&ust=1762796373372331&usg=AOvVaw3DkgsUakhBdOK-fW7kOtPS). 

Seems like there are options to calculate it in R [example](https://search.r-project.org/CRAN/refmans/NetworkToolbox/html/participation.html)


## Local density / cluster / community
Kristin's hypothesis: on average, small systems will have less local density than large systems
How can we test?

## Bipartite project

Create one-mode projection on systems (systems connected if they share sources)
```{r, eval = F}
V(network)$type <- V(network)$type == "system"
system_adjacency = bipartite_projection(network)$proj1
```

# Combine all metrics into one dataframe

Join all system network metrics with system covariates. This can be used as the 'master file' for analysis.
```{r}
system_metrics_comb = left_join(system_centrality, system_path_lengths, by = "pwsid")%>%
  left_join(., diversity_df, by = "pwsid")%>%
  left_join(., all_nodes%>%
              filter(type == "system")%>%
              select(id, system_name:num_sw_sources, system_size, pop_served, gw_access:gw_compliant_w_dw_standards)%>%
              rename(pwsid = id), 
            by = "pwsid")%>%
  left_join(., comb_vulnerability, by = "pwsid")%>%
  mutate(across(c(swrcb_drought_vulnerable, dwr_drought_vulnerable, any_drought_vulnerable, pacific_drought_vulnerable), ~ replace_na(., 0)))%>%
  unique()
  
rm(diversity_df, system_centrality, system_path_lengths, comb_vulnerability)

system_metrics_comb%>%
  select(contains("drought_vulnerable"))

table(system_metrics_comb$any_drought_vulnerable)
```

Join all source network metrics as well
```{r}
source_metrics_comb = left_join(source_centrality, source_path_lengths, by = "source_name")
  
rm(source_centrality, source_path_lengths)
```


Code could potentially be split here so that we have one script that calculates network metrics and produces this master dataframe, which would be the input into a 2nd script focused on visualisations/analysis

# Descriptives of network dataset

```{r}
cat("Number of vertices:", vcount(network), "\n")
cat("Number of systems:", sum(V(network)$type == "system"), "\n")
cat("Number of sources:", sum(V(network)$type == "source"), "\n")

cat("Number of edges:", ecount(network), "\n")
cat("Network density:", round(edge_density(network, loops = FALSE), 4), "\n")
cat("Transitivity:", round(transitivity(network, type = "global"), 4), "\n")

# Basic centrality measures
cat("Average degree:", round(mean(degree(network)), 2), "\n")
cat("Median degree:", round(median(degree(network)), 2), "\n")
cat("Average betweenness:", round(mean(betweenness(network)), 2), "\n")
cat("Average closeness:", round(mean(closeness(network)), 4), "\n")


cat("% sources with 1 connection:", round(length(which(source_metrics_comb$out_degree <= 1))/nrow(source_metrics_comb)*100, 1))
cat("% systems with 1 connection:", round(length(which(system_metrics_comb$total_degree <= 1))/nrow(system_metrics_comb)*100, 1))
```



```{r}
table(system_metrics_comb$source_type)

table(system_metrics_comb$gw_access)
table(system_metrics_comb$gw_compliant_w_dw_standards)

table(system_metrics_comb$provider_type)
table(system_metrics_comb$system_size, useNA = "always")
table(system_metrics_comb$system_size_agg, useNA = "always")


table(network_df$purchased)
nrow(network_df%>%filter(swp_loop == 1 | cvp_loop == 1))
table(network_df$swp_text)
table(network_df$cvp_text)

nrow(network_df%>%filter(!source_type %in% c("PWS", "Non-PWS wholesaler")))
table(system_metrics_comb$provider_type)
table(all_nodes%>%filter(type == "system")%>%pull(source_type), useNA = "always")

summary(system_metrics_comb$in_degree)
```

```{r}
#Small systems that also sell water
cat("Small systems that also sell water:",  nrow(system_metrics_comb%>%filter(system_size_agg == "Small" & pwsid %in% network_df$source_id)))

#Provider type among small systems
table(system_metrics_comb%>%filter(system_size_agg == "Small")%>%pull(provider_type))
```


# System metrics

## Summary stats
System network metrics
Filter for very small/small/medium systems
```{r}
system_metrics_comb%>%
  filter(pop_served <= 10000)%>%
  select(in_degree, out_degree, betweenness, mean_path_length, hhi, n_reachable_sources, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))

system_metrics_comb%>%
  filter(pop_served > 10000)%>%
  select(in_degree, out_degree, betweenness, mean_path_length, hhi, n_reachable_sources, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))

system_metrics_comb%>%
  select(in_degree, out_degree, betweenness, mean_path_length, hhi, n_reachable_sources, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))

wilcox.test(data = system_metrics_comb, in_degree ~ system_size_agg)
wilcox.test(data = system_metrics_comb, out_degree ~ system_size_agg)
wilcox.test(data = system_metrics_comb, betweenness ~ system_size_agg)
wilcox.test(data = system_metrics_comb, hhi ~ system_size_agg)
wilcox.test(data = system_metrics_comb, mean_path_length ~ system_size_agg)
wilcox.test(data = system_metrics_comb, n_reachable_sources ~ system_size_agg)
wilcox.test(data = system_metrics_comb, n_reachable_systems ~ system_size_agg)

wilcox.test(data = system_metrics_comb, gw_access ~ system_size_agg)
wilcox.test(data = system_metrics_comb, any_drought_vulnerable ~ system_size_agg)

system_metrics_comb%>%filter(system_size_agg == "Small" & gw_access == 0 & in_degree == 1)
```

Plots to visualise experience
```{r}
system_metrics_comb%>%filter(pop_served <= 10000)%>%
  select(in_degree:total_degree, betweenness)%>%
  pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
  ggplot(aes(value))+
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~variable, scales = "free")+
  labs(title = "System Centrality Metrics", x = "Value", y = "# of Systems") +
  theme_bw()

system_metrics_comb%>%filter(pop_served <= 10000)%>%
  select(mean_path_length:n_reachable_sources)%>%
  pivot_longer(everything(), names_to = "variable", values_to = "value")%>%
  ggplot(aes(value))+
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~variable, scales = "free")+
  labs(title = "System Path Lengths Metrics", x = "Value", y = "# of Systems") +
  theme_bw()

system_metrics_comb%>%filter(pop_served <= 10000)%>%
  ggplot(aes(hhi))+
  geom_histogram(fill = "steelblue", color = "black", alpha = 0.7) +
  labs(title = "System Source Diversity Metric", x = "Herfindahlâ€“Hirschman Index", y = "# of Systems") +
  theme_bw()
```

Let's make some quick scatter plots just to see the relationships between some of the system-level metrics we calculated
```{r}
ggpairs(system_metrics_comb[c(2:3, 5:6, 12)])+
  labs(title = "Scatterplot Matrix") +
  theme_bw()
```


## Differences by self-supplied

First, we generate a binary variable for self-supplied or not. We consider a system to be self-supplied if it purchases <50% of the water volume it receives.
```{r}
self_supplied = network_df%>%
  filter(purchased == 1)%>%
  group_by(pwsid, purchased)%>%
  reframe(percent_purchased = sum(average_source_usage))%>%
  mutate(self_supplied = ifelse(percent_purchased < 50, 1, 0),
         fully_self_supplied = ifelse(percent_purchased == 0, 1, 0))

system_metrics_comb = system_metrics_comb%>%
  left_join(., self_supplied, by = "pwsid")%>%
  replace_na(list(self_supplied = 1, fully_self_supplied = 1, percent_purchased = 0))

rm(self_supplied)
```


```{r}
system_metrics_comb %>%
  filter(!is.na(system_size_agg)) %>%
  group_by(system_size_agg) %>%
  summarize(
    n = n(),
    self_supplied = mean(self_supplied) * 100,
    fully_self_supplied = mean(fully_self_supplied) * 100,
    drought_vulnerable = mean(any_drought_vulnerable) * 100) %>%
  mutate(across(-c(system_size_agg, n), ~ round(., 1)))

chisq.test(system_metrics_comb$system_size_agg, system_metrics_comb$self_supplied)
chisq.test(system_metrics_comb$system_size_agg, system_metrics_comb$fully_self_supplied)
chisq.test(system_metrics_comb$system_size_agg, system_metrics_comb$any_drought_vulnerable)

system_metrics_comb%>%filter(system_size_agg == "Small" & (gw_compliant_w_dw_standards == 0 | is.na(gw_compliant_w_dw_standards)) & in_degree == 1 & fully_self_supplied == 1)
```


```{r}
small_system_metrics_comb = system_metrics_comb%>%
  filter(system_size_agg == "Small")
```


Now, we can make a quick plot and statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.
```{r}
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), hhi))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "HHI")
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), in_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "In-Degree Centrality")
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), mean_path_length))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "Mean Path Length to Source")
```

```{r}
wilcox.test(hhi ~ self_supplied, data = small_system_metrics_comb)
aggregate(hhi ~ self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ self_supplied, data = small_system_metrics_comb)
aggregate(in_degree ~ self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ self_supplied, data = small_system_metrics_comb)
aggregate(mean_path_length ~ self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(n_reachable_sources ~ self_supplied, data = small_system_metrics_comb)
aggregate(n_reachable_sources ~ self_supplied, data = small_system_metrics_comb, FUN = mean)
```


```{r}
wilcox.test(hhi ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(hhi ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(in_degree ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(mean_path_length ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(n_reachable_sources ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(n_reachable_sources ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)
```




## Differences by drought impacted



Quick statistical test to see if distribution is different by group
Using mann-whitney test since data is non-parametric
```{r}
wilcox.test(hhi ~ any_drought_vulnerable, data = small_system_metrics_comb)
aggregate(hhi ~ any_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ any_drought_vulnerable, data = small_system_metrics_comb)
aggregate(in_degree ~ any_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ any_drought_vulnerable, data = small_system_metrics_comb)
aggregate(mean_path_length ~ any_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(n_reachable_sources ~ any_drought_vulnerable, data = small_system_metrics_comb)
aggregate(n_reachable_sources ~ any_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)
```

```{r}
wilcox.test(hhi ~ dwr_drought_vulnerable, data = small_system_metrics_comb)
aggregate(hhi ~ dwr_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ dwr_drought_vulnerable, data = small_system_metrics_comb)
aggregate(in_degree ~ dwr_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ dwr_drought_vulnerable, data = small_system_metrics_comb)
aggregate(mean_path_length ~ dwr_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(n_reachable_sources ~ dwr_drought_vulnerable, data = small_system_metrics_comb)
aggregate(n_reachable_sources ~ dwr_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)
```

```{r}
wilcox.test(hhi ~ pacific_drought_vulnerable, data = small_system_metrics_comb)
aggregate(hhi ~ pacific_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ pacific_drought_vulnerable, data = small_system_metrics_comb)
aggregate(in_degree ~ pacific_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ pacific_drought_vulnerable, data = small_system_metrics_comb)
aggregate(mean_path_length ~ pacific_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)
```

Tests indicate that small systems designated as drought-vulnerable tend to have shorter path length (ie: less removed from their original sources) than non-drought-vulnerable systems. HHI and # of sources are not significant. 

## Differences by size



```{r}
system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(in_degree = mean(in_degree, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = in_degree, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean In-Degree Centrality")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(hhi = mean(hhi, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = hhi, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean HHI")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(mean_path_length = mean(mean_path_length, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = mean_path_length, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean Path Length")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(n_reachable_sources = mean(n_reachable_sources, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = n_reachable_sources, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "# of Reachable Sources")+
  theme(legend.position = "none")


system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(drought_vulnerable = mean(drought_vulnerable, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = drought_vulnerable, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Proportion of Drought-Vulnerable Systems")+
  theme(legend.position = "none")
```
```{r}
ggplot(system_metrics_comb, aes(pop_served, hhi)) +
  geom_point()+
  #geom_density_2d_filled() +
  #geom_hex(bins = 40) +scale_fill_viridis_c() +
  theme_minimal()+
  scale_x_log10()
```


```{r}
summary(lm(hhi ~ pop_served, data = system_metrics_comb))
summary(lm(in_degree ~ pop_served, data = system_metrics_comb))
summary(lm(mean_path_length ~ pop_served, data = system_metrics_comb))
summary(lm(n_reachable_sources ~ pop_served, data = system_metrics_comb))
```

We generally see that as we go from very small to very large systems, in-degree centrality and mean path length increase, and HHI decreases, indicating that larger systems have more sources, greater source diversity, and are more removed from their original source. 
Based on a simple regression, these trends are statistically significant for HHI and in-degree.


# Source metrics

## Summary stats
```{r}
source_metrics_comb%>%
  select(out_degree, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))
```

```{r}
source_metrics_comb
table(source_metrics_comb$source_type)
```


## Differences by serving small vs large systems

First, let's determine the primary system size each source serves. We use the median population served to determine if large systems or small systems are the primary recipients. 

```{r}
system_size_served = network_df%>%
  group_by(source_name)%>%
  reframe(median_pop_served = median(pop_served, na.rm = T))%>%
  mutate(primary_system_size_served = ifelse(median_pop_served <= 10000, "Small", "Large"))

source_metrics_comb = source_metrics_comb%>%
  left_join(., system_size_served, by = "source_name")

table(source_metrics_comb$primary_system_size_served)

rm(system_size_served)


```
Now, we can make a quick statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.


```{r}
wilcox.test(out_degree ~ primary_system_size_served, data = source_metrics_comb)
aggregate(out_degree ~ primary_system_size_served, data = source_metrics_comb, FUN = mean)

wilcox.test(n_reachable_systems ~ primary_system_size_served, data = source_metrics_comb)
aggregate(n_reachable_systems ~ primary_system_size_served, data = source_metrics_comb, FUN = mean)
```
Sources that primarily serve larger systems tend to have greater out-degree and number of reachable systems (ie: directly supply more systems and also indirectly reach more systems through the network)


## Differences by serving drought-impacted vs non-drought-impacted systems

First, we determine whether each source serves any drought-impacted system or not
```{r}
serve_drought_systems = network_df%>%
  left_join(., system_metrics_comb%>%select(pwsid, any_drought_vulnerable), by = "pwsid")%>%
  group_by(source_name)%>%
  reframe(drought_system_served = ifelse(mean(any_drought_vulnerable)>= 0.5, 1, 0))

source_metrics_comb = source_metrics_comb%>%
  left_join(., serve_drought_systems, by = "source_name")

table(source_metrics_comb$drought_system_served)
length(which(source_metrics_comb$drought_system_served == 1))/nrow(source_metrics_comb)

rm(serve_drought_systems)
```

```{r}
wilcox.test(out_degree ~ drought_system_served, data = source_metrics_comb)
aggregate(out_degree ~ drought_system_served, data = source_metrics_comb, FUN = mean)

wilcox.test(n_reachable_systems ~ drought_system_served, data = source_metrics_comb)
aggregate(n_reachable_systems ~ drought_system_served, data = source_metrics_comb, FUN = mean)
```
Sources that serve a drought-impacted system tend to have greater number of reachable systems (ie: indirectly reach more systems through the network). Out-degree does not differ significantly by whether or not a source serves any drought-impacted systems.

# Community detection/clustering

```{r}
network_sparse = network_df%>%
  select(pwsid, source_name)

network_sparse_w_sources = network_sparse%>%
  inner_join(., source_metrics_comb%>%select(source_name, out_degree, n_reachable_systems), by = "source_name")
network_sparse_w_systems = network_sparse%>%
  inner_join(., system_metrics_comb%>%select(pwsid, out_degree, n_reachable_systems), by = c("source_name" = "pwsid"))

source_stats_aggregated = rbind(network_sparse_w_sources, network_sparse_w_systems)%>%
  group_by(pwsid)%>%
  reframe(mean_source_out_degree = mean(out_degree),
          mean_source_n_reachable_systems = mean(n_reachable_systems))

system_metrics_comb = system_metrics_comb%>%
  left_join(., source_stats_aggregated, by = "pwsid")

rm(network_sparse, network_sparse_w_sources, network_sparse_w_systems, source_stats_aggregated)
```


```{r}
# Select features for clustering
features <- system_metrics_comb %>%
  select(-c(pwsid, system_size, pop_served, system_size_agg, self_supplied, fully_self_supplied, num_sw_sources, system_name:state_classification, purchased, pacific_drought_vulnerable, dwr_drought_vulnerable, total_degree, median_path_length:min_path_length, gw_access:gw_compliant_w_dw_standards))

small_system_features = small_system_metrics_comb%>%
  select(-c(pwsid, system_size, pop_served, system_size_agg, self_supplied, fully_self_supplied, num_sw_sources, system_name:state_classification, purchased, swrcb_drought_vulnerable, pacific_drought_vulnerable, dwr_drought_vulnerable, any_drought_vulnerable, total_degree, median_path_length:min_path_length, gw_access:gw_compliant_w_dw_standards))

small_system_metrics_comb
```


```{r, eval = F}
# Determine optimal number of clusters (optional)
fviz_nbclust(small_system_features, kmeans, method = "wss") + 
  labs(subtitle = "Elbow Method")
```


```{r}
library(mclust)

# Model-based clustering - automatically determines optimal variables
mclust_result <- Mclust(small_system_features)

# Get optimal number of clusters and variables
summary(mclust_result)

# Add to data
clusters = small_system_metrics_comb %>%
  mutate(mclust_cluster = mclust_result$classification)%>%
  select(-c(pwsid, total_degree, median_path_length:min_path_length, system_name:state_classification, system_size:num_sw_sources, dwr_drought_vulnerable:pacific_drought_vulnerable, purchased, gw_compliant_w_dw_standards))%>%
  group_by(mclust_cluster)%>%
  reframe(n = n(), 
          across(everything(), ~ mean(.x, na.rm = TRUE)))

clusters
```

```{r}
library(ggradar)
library(scales)
ggradar(clusters%>%
          select(1, 3:4, hhi, gw_access, percent_purchased)%>%
          mutate(across(c(in_degree, out_degree, hhi, percent_purchased), rescale))%>%
          rename("In-Degree" = in_degree, 
                 "Out-Degree" = out_degree, 
                 "Source Diversity \n (HHI)" = hhi, 
                 "GW Access" = gw_access,
                 "% Volume \n Purchased" = percent_purchased),
        plot.extent.x.sf = 1.3,
        group.colours = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "coral1"),
        group.point.size = 4)+
        labs(colour = "Cluster #")+
        theme(
          legend.position = "left", 
          legend.title = element_text(size = 15), 
          legend.text = element_text(size = 12))
```





```{r}
# Perform k-means clustering
set.seed(123)
k <- 2  # Based on your typology idea
kmeans_result <- kmeans(small_system_features%>%select(-mean_source_out_degree, -mean_source_n_reachable_systems), centers = k, nstart = 5)

# Add cluster assignments
small_system_metrics_comb$kmeans_cluster <- kmeans_result$cluster
```


```{r}
small_system_metrics_comb%>%
              group_by(kmeans_cluster)%>%
              reframe(n = n(),
                      across(where(is.numeric), mean, na.rm = T))
```


```{r}
# Create a focused summary with key variables
library(kableExtra)
key_summary <- cluster_summary %>%
  select(cluster, in_degree:mean_source_n_reachable_systems, size:pop_served_na)%>%
  mutate(across(where(is.numeric), round, 2)) %>%
  kbl(col.names = c("Cluster", "In-Degree", "Out-Degree", "Betweenness", 
                    "Mean Path Length", "# Reachable Sources", "# Reachable Systems", "% Volume Purchased", "Mean Source Out-Degree", "Mean Source # of Reachable Systems", "Size", "Pop. Served", "Drought Vul.", "Systems with No Pop. Served")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
  
key_summary

writeLines(key_summary, "Manuscript outputs/cluster_table.png")
```
Seems to break into 3 clusters:
1) Few # of sources, hardly transfers out water, very close to og sources (low mean path length) since they barely purchase any. Sources they get water from aren't as heavily used. More likely to be drought-vulnerable

2) Few # of sources, hardly transfers out water. Purchases a lot more water (mean is 83%), so a bit further removed from their sources (higher mean path length and # of reachable sources than cluster 1).

3) Transfer out a lot of water (mean out-degree almost 4 and betweenness high). Purchase a decent amount of water and seem to sell a lot of it on.


# Figures

```{r}
systems = st_read("Data/Outputs/Shapefiles for dashboard/20251210_systems.shp")

sources = st_read("Data/Outputs/Shapefiles for dashboard/20251210_sources.shp")

systems%>%data.frame()

library(tigris)
ca_polygon <- states(cb = TRUE, resolution = "20m") %>%
  filter(NAME == "California")

# Define manual color palettes
systems_colors <- c("#FFA500","#FF0000","#FFFF00")
sources_colors <- c("#4169E1", "#800080")

tm_shape(ca_polygon)+
  tm_borders()+
  tm_shape(systems)+
  tm_dots("prvdr_t", title = "adsfiopasjdo")+
  tm_shape(sources)+
  tm_dots(fill = "src_ty_", title = "Source Type")
```

