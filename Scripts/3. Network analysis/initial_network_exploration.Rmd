

# Set up

Import packages
```{r}
suppressPackageStartupMessages({
  suppressWarnings({
  library(tidyverse)   # Data wrangling
  library(here)        # File management
  library(igraph)      # Network analysis
  library(GGally)      # Exploratory scatter plots
  library(psych)       # Summary stats
  library(factoextra)  # K-means
  })})
```

Set settings and universal variables
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here())
```

# Import data

## Network data
Our cleaned and processed network data generated into an igraph object
```{r}
load("data for upload/20251218_network_igraph.Rdata")

network_df = read.csv("Data/Outputs/20251215_network_joined.csv")
``` 

## Drought vulnerability

DWR small system vulnerability data for validation, hosted on [this page](https://water.ca.gov/Programs/Water-Use-And-Efficiency/SB-552/SB-552-Tool) and downloaded as a csv from [this link](https://data.cnra.ca.gov/dataset/i07-water-shortage-vulnerability-small-water-systems).

More information on documentation and methodology is available [here](https://data.cnra.ca.gov/dataset/water-shortage-vulnerability-technical-methods/resource/090baaf3-dc47-4e21-8eba-d9bf499a76a0)
```{r}
dwr_vulnerability = read.csv("Data/Source/Small System Drought Vulnerability/i07_Water_Shortage_Vulnerability_Small_Water_Systems.csv")%>%
  select(SABL_PWSID, SC5e_Drought_Impact)%>%
  rename(pwsid = 1, drought_vulnerable = 2)%>%
  mutate(drought_vulnerable = ifelse(grepl("Listed as having", drought_vulnerable), 1, 0))
```

To get more commprehensive drought vulnerability data, we also add to this list a dataset of drought-vulnerable public water systems compiled by the Pacific Institute as part of [this](https://pacinst.org/wp-content/uploads/2017/01/PI_DroughtAndEquityInCA_Jan_2017.pdf) 2017 report. The data sources are also listed [here](https://pacinst.org/wp-content/uploads/2017/01/PI_DroughtAndEquityInCA-2017_Appendix1A_3.pdf). 
```{r}
pacific_vulnerability = read.csv("Data/Source/Small System Drought Vulnerability/Appendix-1B-Drought-Impacted-Public-Water-Systems.xlsx - DroughtImpactedPWS.csv")%>%
  rename(pwsid = PWSID)%>%
  select(pwsid)%>%
  filter(pwsid != "")%>%
  mutate(drought_vulnerable = 1, pacific_drought_vulnerable = 1)
```

Now we can combine the two. We'll consider a system drought vulnerable if it appears in any of the vulnerability datasets. 
```{r}
comb_vulnerability = bind_rows(dwr_vulnerability, pacific_vulnerability)%>%
  #filter(pwsid == "CA5610068")%>%
  group_by(pwsid)%>%
  reframe(
    drought_vulnerable = max(drought_vulnerable, na.rm = T),
    pacific_drought_vulnerable = max(pacific_drought_vulnerable, na.rm = T)) %>%
  ungroup() %>%
  mutate(across(c(drought_vulnerable, pacific_drought_vulnerable), 
                ~ ifelse(is.infinite(.), NA, .)))

rm(dwr_vulnerability, pacific_vulnerability)
```

# Calculating Metrics

## Centrality

Calculate in, out, and total degree centrality for systems. Compile into one 'master' dataframe with system centralities 
```{r}
system_centrality = all_nodes%>%
  filter(type == "system")%>%
  rename(in_degree = num_sw_sources,
         out_degree = num_systems_served,
         pwsid = id)%>%
  mutate(
    out_degree = replace_na(out_degree, 0),
    total_degree = in_degree + out_degree)%>%
  arrange(-total_degree)%>%
  select(pwsid, in_degree, out_degree, total_degree)
```

Calculate betweenness centrality - systems that are major redistribution hubs (ie: measure of centrality based on shortest paths that pass through a given node). Add to master dataframe.
```{r}
betweenness_all = betweenness(network, directed = TRUE)
system_centrality$betweenness = betweenness_all[V(network)$type == "system"]

rm(betweenness_all)
```

Out degree centrality for sources
```{r}
source_centrality = all_nodes%>%
  rename(source_name = id, out_degree = num_systems_served)%>%
  filter(type == "source")%>%
  arrange(-out_degree)%>%
  select(1:3)
```

## Path length

Calculate shortest paths from sources to systems
```{r}
sources = V(network)[type == "source"]
systems = V(network)[type == "system"]

# Get shortest paths between all sources to all systems
path_length_matrix = distances(network, v = sources, to = systems, mode = "out")
#path_lengths = as.vector(path_length_matrix[is.finite(as.vector(path_length_matrix))])

# Get shortest paths between all systems (for reachable systems calculation)
system_to_system_matrix = distances(network, v = systems, to = systems, mode = "out")
```

Summary stats for sources' path lengths
```{r}
source_path_lengths = data.frame(
  source_name = sources$name,
  n_reachable_systems = apply(path_length_matrix, 1, function(x) sum(is.finite(x))))
```

Summary stats for systems' path lengths

Right now, this is ONLY when systems are the final node on a path
```{r}
system_path_lengths = data.frame(
  pwsid = systems$name,
  mean_path_length = apply(path_length_matrix, 2, function(x) mean(x[is.finite(x)])),
  median_path_length = apply(path_length_matrix, 2, function(x) median(x[is.finite(x)])),
  max_path_length = apply(path_length_matrix, 2, function(x) max(x[is.finite(x)])),
  min_path_length = apply(path_length_matrix, 2, function(x) min(x[is.finite(x)])),
  n_reachable_sources = apply(path_length_matrix, 2, function(x) sum(is.finite(x))),
  n_reachable_systems = apply(system_to_system_matrix, 1, function(x) sum(is.finite(x)) - 1)) %>%  # Subtract 1 to exclude self
  arrange(-max_path_length)

rm(path_length_matrix, system_to_system_matrix)
```

## Source diversity

```{r}
# Calculate HHI for each system
system_diversity = sapply(systems, function(system) {
  # Get edges going into this system (sources supplying it)
  incoming_edges = E(network)[.to(system)]
  
  if (length(incoming_edges) == 0) return(NA)  # no sources
  
  # Get the usage percentages for this system's sources
  usage_percentages = incoming_edges$average_source_usage/100
  
  # Calculate HHI (sum of squares of market shares, scaled 0-10000)
  hhi = sum((usage_percentages * 100)^2)
  
  return(hhi)})

# Create a diversity data frame
diversity_df = data.frame(
  pwsid = systems$name,
  hhi = system_diversity,
  stringsAsFactors = FALSE,
  row.names = NULL)

rm(system_diversity, systems, sources)
```

Kristin also mentioned [participation coefficient](https://www.google.com/url?q=https://www.nature.com/articles/s41467-017-01189-w%23:~:text%3DParticipation%2520coefficient,-Given%2520a%2520particular%26text%3Dwhere%2520%257BK_i%257D%2520is%2520the%2520sum,are%2520to%2520a%2520single%2520community&sa=D&source=docs&ust=1762796373372331&usg=AOvVaw3DkgsUakhBdOK-fW7kOtPS). 

Seems like there are options to calculate it in R [example](https://search.r-project.org/CRAN/refmans/NetworkToolbox/html/participation.html)


## Local density / cluster / community
Kristin's hypothesis: on average, small systems will have less local density than large systems
How can we test?

## Bipartite project

Create one-mode projection on systems (systems connected if they share sources)
```{r, eval = F}
V(network)$type <- V(network)$type == "system"
system_adjacency = bipartite_projection(network)$proj1
```

# Combine all metrics into one dataframe

Join all system network metrics with system covariates. This can be used as the 'master file' for analysis.
```{r}
system_metrics_comb = left_join(system_centrality, system_path_lengths, by = "pwsid")%>%
  left_join(., diversity_df, by = "pwsid")%>%
  left_join(., all_nodes%>%
              filter(type == "system")%>%
              select(id, system_name:num_sw_sources, system_size, pop_served)%>%
              rename(pwsid = id), 
            by = "pwsid")%>%
  left_join(., comb_vulnerability, by = "pwsid")%>%
  mutate(across(c(drought_vulnerable, pacific_drought_vulnerable), ~ replace_na(., 0)))
  
rm(diversity_df, system_centrality, system_path_lengths, comb_vulnerability)
```

Join all source network metrics as well
```{r}
source_metrics_comb = left_join(source_centrality, source_path_lengths, by = "source_name")
  
rm(source_centrality, source_path_lengths)
```


Code could potentially be split here so that we have one script that calculates network metrics and produces this master dataframe, which would be the input into a 2nd script focused on visualisations/analysis

# Descriptives of network dataset

```{r}
cat("Number of vertices:", vcount(network), "\n")
cat("Number of systems:", sum(V(network)$type == "system"), "\n")
cat("Number of sources:", sum(V(network)$type == "source"), "\n")

cat("Number of edges:", ecount(network), "\n")
cat("Network density:", round(edge_density(network, loops = FALSE), 4), "\n")
cat("Transitivity:", round(transitivity(network, type = "global"), 4), "\n")


# Basic centrality measures
cat("Average degree:", round(mean(degree(network)), 2), "\n")
cat("Average betweenness:", round(mean(betweenness(network)), 2), "\n")
cat("Average closeness:", round(mean(closeness(network)), 4), "\n")
```


```{r}
table(all_nodes$source_type)

table(all_nodes$gw_access)
table(all_nodes$gw_compliant_w_dw_standards)
table(all_nodes$provider_type)
table(all_nodes%>%filter(type == "system")%>%pull(system_size), useNA = "always")


table(network_df$purchased)
nrow(network_df%>%filter(swp_loop == 1 | cvp_loop == 1))
table(network_df$swp_text)
table(network_df$cvp_text)

nrow(network_df%>%filter(!source_type %in% c("PWS", "Non-PWS wholesaler")))
```

# System metrics

## Summary stats
System network metrics
Filter for very small/small/medium systems
```{r}
system_metrics_comb%>%
  filter(pop_served <= 10000)%>%
  select(in_degree, out_degree, betweenness, mean_path_length, hhi, n_reachable_sources, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))

system_metrics_comb%>%
  filter(pop_served > 10000)%>%
  select(in_degree, out_degree, betweenness, mean_path_length, hhi, n_reachable_sources, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))

system_metrics_comb%>%
  select(in_degree, out_degree, betweenness, mean_path_length, hhi, n_reachable_sources, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))
```

Plots to visualise experience
```{r}
system_metrics_comb%>%filter(pop_served <= 10000)%>%
  select(in_degree:total_degree, betweenness)%>%
  pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
  ggplot(aes(value))+
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~variable, scales = "free")+
  labs(title = "System Centrality Metrics", x = "Value", y = "# of Systems") +
  theme_bw()

system_metrics_comb%>%filter(pop_served <= 10000)%>%
  select(mean_path_length:n_reachable_sources)%>%
  pivot_longer(everything(), names_to = "variable", values_to = "value")%>%
  ggplot(aes(value))+
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~variable, scales = "free")+
  labs(title = "System Path Lengths Metrics", x = "Value", y = "# of Systems") +
  theme_bw()

system_metrics_comb%>%filter(pop_served <= 10000)%>%
  ggplot(aes(hhi))+
  geom_histogram(fill = "steelblue", color = "black", alpha = 0.7) +
  labs(title = "System Source Diversity Metric", x = "Herfindahlâ€“Hirschman Index", y = "# of Systems") +
  theme_bw()
```

Let's make some quick scatter plots just to see the relationships between some of the system-level metrics we calculated
```{r}
ggpairs(system_metrics_comb[c(2:3, 5:6, 12)])+
  labs(title = "Scatterplot Matrix") +
  theme_bw()
```


## Differences by self-supplied

First, we generate a binary variable for self-supplied or not. We consider a system to be self-supplied if it purchases <50% of the water volume it receives.
```{r}
self_supplied = network_df%>%
  filter(purchased == 1)%>%
  group_by(pwsid, purchased)%>%
  reframe(percent_purchased = sum(average_source_usage))%>%
  mutate(self_supplied = ifelse(percent_purchased < 50, 1, 0),
         fully_self_supplied = ifelse(percent_purchased == 0, 1, 0))

system_metrics_comb = system_metrics_comb%>%
  left_join(., self_supplied, by = "pwsid")%>%
  replace_na(list(self_supplied = 1, fully_self_supplied = 1, percent_purchased = 0))

rm(self_supplied)
```


```{r}
system_metrics_comb %>%
  filter(!is.na(system_size_agg)) %>%
  group_by(system_size_agg) %>%
  summarize(
    n = n(),
    self_supplied = mean(self_supplied) * 100,
    fully_self_supplied = mean(fully_self_supplied) * 100,
    drought_vulnerable = mean(drought_vulnerable) * 100) %>%
  mutate(across(-c(system_size_agg, n), ~ round(., 1)))

chisq.test(system_metrics_comb$system_size_agg, system_metrics_comb$self_supplied)
chisq.test(system_metrics_comb$system_size_agg, system_metrics_comb$fully_self_supplied)
chisq.test(system_metrics_comb$system_size_agg, system_metrics_comb$drought_vulnerable)

small_system_metrics_comb = system_metrics_comb%>%
  filter(system_size_agg == "Small")
```


Now, we can make a quick plot and statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.
```{r}
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), hhi))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "HHI")
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), in_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "In-Degree Centrality")
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), mean_path_length))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "Mean Path Length to Source")
```

```{r}
wilcox.test(hhi ~ self_supplied, data = small_system_metrics_comb)
aggregate(hhi ~ self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ self_supplied, data = small_system_metrics_comb)
aggregate(in_degree ~ self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ self_supplied, data = small_system_metrics_comb)
aggregate(mean_path_length ~ self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(n_reachable_sources ~ self_supplied, data = small_system_metrics_comb)
aggregate(n_reachable_sources ~ self_supplied, data = small_system_metrics_comb, FUN = mean)
```


```{r}
wilcox.test(hhi ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(hhi ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(in_degree ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(mean_path_length ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)

wilcox.test(n_reachable_sources ~ fully_self_supplied, data = small_system_metrics_comb)
aggregate(n_reachable_sources ~ fully_self_supplied, data = small_system_metrics_comb, FUN = mean)
```




## Differences by drought impacted


Plots comparing distributions of vulnerability metrics by DWR drought vulnerability assessment
```{r}
system_metrics_comb%>%
  filter(!is.na(drought_vulnerable))%>%
  ggplot(aes(as.factor(drought_vulnerable), hhi))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "DWR Drought Vulnerability", y = "HHI")
system_metrics_comb%>%
  filter(!is.na(drought_vulnerable))%>%
  ggplot(aes(as.factor(drought_vulnerable), in_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "DWR Drought Vulnerability", y = "In-Degree Centrality")
system_metrics_comb%>%
  filter(!is.na(drought_vulnerable))%>%
  ggplot(aes(as.factor(drought_vulnerable), mean_path_length))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "DWR Drought Vulnerability", y = "Mean Path Length to Source")
```


Quick statistical test to see if distribution is different by group
Using mann-whitney test since data is non-parametric
```{r}
wilcox.test(hhi ~ drought_vulnerable, data = small_system_metrics_comb)
aggregate(hhi ~ drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ drought_vulnerable, data = small_system_metrics_comb)
aggregate(in_degree ~ drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ drought_vulnerable, data = small_system_metrics_comb)
aggregate(mean_path_length ~ drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(n_reachable_sources ~ drought_vulnerable, data = small_system_metrics_comb)
aggregate(n_reachable_sources ~ drought_vulnerable, data = small_system_metrics_comb, FUN = mean)


wilcox.test(hhi ~ pacific_drought_vulnerable, data = small_system_metrics_comb)
aggregate(hhi ~ pacific_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ pacific_drought_vulnerable, data = small_system_metrics_comb)
aggregate(in_degree ~ pacific_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ pacific_drought_vulnerable, data = small_system_metrics_comb)
aggregate(mean_path_length ~ pacific_drought_vulnerable, data = small_system_metrics_comb, FUN = mean)
```

Tests indicate that small systems designated as drought-vulnerable tend to have shorter path length (ie: less removed from their original sources) than non-drought-vulnerable systems. HHI and # of sources are not significant. 

## Differences by size

```{r}
system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(in_degree = mean(in_degree, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = in_degree, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean In-Degree Centrality")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(hhi = mean(hhi, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = hhi, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean HHI")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(mean_path_length = mean(mean_path_length, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = mean_path_length, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean Path Length")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(n_reachable_sources = mean(n_reachable_sources, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = n_reachable_sources, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "# of Reachable Sources")+
  theme(legend.position = "none")


system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(drought_vulnerable = mean(drought_vulnerable, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = drought_vulnerable, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Proportion of Drought-Vulnerable Systems")+
  theme(legend.position = "none")
```
```{r}
ggplot(system_metrics_comb, aes(pop_served, hhi)) +
  geom_point()+
  #geom_density_2d_filled() +
  #geom_hex(bins = 40) +scale_fill_viridis_c() +
  theme_minimal()+
  scale_x_log10()
```


```{r}
summary(lm(hhi ~ pop_served, data = system_metrics_comb))
summary(lm(in_degree ~ pop_served, data = system_metrics_comb))
summary(lm(mean_path_length ~ pop_served, data = system_metrics_comb))
summary(lm(n_reachable_sources ~ pop_served, data = system_metrics_comb))
```

We generally see that as we go from very small to very large systems, in-degree centrality and mean path length increase, and HHI decreases, indicating that larger systems have more sources, greater source diversity, and are more removed from their original source. 
Based on a simple regression, these trends are statistically significant for HHI and in-degree.


# Source metrics

## Summary stats
```{r}
source_metrics_comb%>%
  select(out_degree, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))
```

## Differences by serving small vs large systems

First, let's determine the primary system size each source serves. We use the median population served to determine if large systems or small systems are the primary recipients. 

```{r}
system_size_served = network_df%>%
  group_by(source_name)%>%
  reframe(median_pop_served = median(pop_served, na.rm = T))%>%
  mutate(primary_system_size_served = ifelse(median_pop_served <= 10000, "Small", "Large"))

source_metrics_comb = source_metrics_comb%>%
  left_join(., system_size_served, by = "source_name")

table(source_metrics_comb$primary_system_size_served)

rm(system_size_served)


```
Now, we can make a quick plot and statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.
```{r}
source_metrics_comb%>%
  filter(!is.na(primary_system_size_served))%>%
  ggplot(aes(as.factor(primary_system_size_served), out_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Primary System Size Served", y = "Mean Out-Degree Centrality")
source_metrics_comb%>%
  filter(!is.na(primary_system_size_served))%>%
  ggplot(aes(as.factor(primary_system_size_served), n_reachable_systems))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Primary System Size Served", y = "Mean Number of Reachable Systems")
```

```{r}
wilcox.test(out_degree ~ primary_system_size_served, data = source_metrics_comb)
aggregate(out_degree ~ primary_system_size_served, data = source_metrics_comb, FUN = mean)

wilcox.test(n_reachable_systems ~ primary_system_size_served, data = source_metrics_comb)
aggregate(n_reachable_systems ~ primary_system_size_served, data = source_metrics_comb, FUN = mean)
```
Sources that primarily serve larger systems tend to have greater out-degree and number of reachable systems (ie: directly supply more systems and also indirectly reach more systems through the network)


## Differences by serving drought-impacted vs non-drought-impacted systems

First, we determine whether each source serves any drought-impacted system or not
```{r}
serve_drought_systems = network_df%>%
  left_join(., system_metrics_comb%>%select(pwsid, drought_vulnerable), by = "pwsid")%>%
  group_by(source_name)%>%
  reframe(drought_system_served = ifelse(mean(drought_vulnerable)>= 0.5, 1, 0))

source_metrics_comb = source_metrics_comb%>%
  left_join(., serve_drought_systems, by = "source_name")

table(source_metrics_comb$drought_system_served)

rm(serve_drought_systems)
```

Now, we can make a quick plot and statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.
```{r}
source_metrics_comb%>%
  ggplot(aes(as.factor(drought_system_served), out_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Serves Drought-Impacted Systems", y = "Mean Out-Degree Centrality")
source_metrics_comb%>%
  ggplot(aes(as.factor(drought_system_served), n_reachable_systems))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Serves Drought-Impacted Systems", y = "Mean Number of Reachable Systems")
```

```{r}
wilcox.test(out_degree ~ drought_system_served, data = source_metrics_comb)
aggregate(out_degree ~ drought_system_served, data = source_metrics_comb, FUN = mean)

wilcox.test(n_reachable_systems ~ drought_system_served, data = source_metrics_comb)
aggregate(n_reachable_systems ~ drought_system_served, data = source_metrics_comb, FUN = mean)
```
Sources that serve a drought-impacted system tend to have greater number of reachable systems (ie: indirectly reach more systems through the network). Out-degree does not differ significantly by whether or not a source serves any drought-impacted systems.

# Community detection/clustering

```{r}
network_sparse = network_df%>%
  select(pwsid, source_name)

network_sparse_w_sources = network_sparse%>%
  inner_join(., source_metrics_comb%>%select(source_name, out_degree, n_reachable_systems), by = "source_name")
network_sparse_w_systems = network_sparse%>%
  inner_join(., system_metrics_comb%>%select(pwsid, out_degree, n_reachable_systems), by = c("source_name" = "pwsid"))

source_stats_aggregated = rbind(network_sparse_w_sources, network_sparse_w_systems)%>%
  group_by(pwsid)%>%
  reframe(mean_source_out_degree = mean(out_degree),
          mean_source_n_reachable_systems = mean(n_reachable_systems))

system_metrics_comb = system_metrics_comb%>%
  left_join(., source_stats_aggregated, by = "pwsid")

system_metrics_comb

rm(network_sparse, network_sparse_w_sources, network_sparse_w_systems, source_stats_aggregated)
```


```{r}
# Select features for clustering
features <- system_metrics_comb %>%
  select(-c(pwsid, system_size, pop_served, system_size_agg, self_supplied, fully_self_supplied, hhi, num_sw_sources, system_name:state_classification, purchased, drought_vulnerable, pacific_drought_vulnerable, total_degree, median_path_length:min_path_length))

# Determine optimal number of clusters (optional)
fviz_nbclust(features, kmeans, method = "wss") + 
  labs(subtitle = "Elbow Method")
```


```{r}
# Perform k-means clustering
set.seed(123)
k <- 3  # Based on your typology idea
kmeans_result <- kmeans(features, centers = k, nstart = 25)

# Add cluster assignments
system_metrics_comb$cluster <- kmeans_result$cluster

# Examine cluster centers to label them
cluster_centers <- as.data.frame(kmeans_result$centers)
#rownames(cluster_centers) <- paste("Cluster", 1:k)
cluster_centers$cluster = 1:k
cluster_centers$size <- table(kmeans_result$cluster)
```


```{r}
cluster_summary = cluster_centers%>%
  left_join(., system_metrics_comb%>%
              group_by(cluster)%>%
              reframe(mean_pop_served = mean(pop_served, na.rm = T),
                      mean_drought = mean(drought_vulnerable, na.rm = T),
                      pop_served_na = mean(ifelse(is.na(pop_served), 1, 0))),
            by = "cluster")

# Create a focused summary with key variables
library(kableExtra)
key_summary <- cluster_summary %>%
  select(cluster, in_degree:mean_source_n_reachable_systems, size:pop_served_na)%>%
  mutate(across(where(is.numeric), round, 2)) %>%
  kbl(col.names = c("Cluster", "In-Degree", "Out-Degree", "Betweenness", 
                    "Mean Path Length", "# Reachable Sources", "# Reachable Systems", "% Volume Purchased", "Mean Source Out-Degree", "Mean Source # of Reachable Systems", "Size", "Pop. Served", "Drought Vul.", "Systems with No Pop. Served")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
  
key_summary

writeLines(key_summary, "Manuscript outputs/cluster_table.png")
```
Seems to break into 3 clusters:
1) Few # of sources, hardly transfers out water, very close to og sources (low mean path length) since they barely purchase any. Sources they get water from aren't as heavily used. More likely to be drought-vulnerable

2) Few # of sources, hardly transfers out water. Purchases a lot more water (mean is 83%), so a bit further removed from their sources (higher mean path length and # of reachable sources than cluster 1).

3) Transfer out a lot of water (mean out-degree almost 4 and betweenness high). Purchase a decent amount of water and seem to sell a lot of it on.



```{r}
isolated_systems = system_metrics_comb%>%
  filter(in_degree == 1 & mean_source_out_degree == 1 & out_degree == 0 & mean_path_length == 1)


network_df%>%
  filter(pwsid %in% isolated_systems$pwsid)%>%
  arrange(pwsid)
```

