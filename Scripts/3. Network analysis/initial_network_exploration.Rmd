

# Set up

Import packages
```{r}
suppressPackageStartupMessages({
  suppressWarnings({
  library(tidyverse)   # Data wrangling
  library(here)        # File management
  library(igraph)      # Network analysis
  library(GGally)      # Exploratory scatter plots
  library(psych)       # Summary stats
  })})
```

Set settings and universal variables
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here())
```

# Import data

## Network data
Our cleaned and processed network data generated into an igraph object
```{r}
load("data for upload/20251125_network_igraph.Rdata")

network_df = read.csv("Data/Outputs/20251125_network_joined.csv")

all_nodes = all_nodes%>%
  mutate(system_size = case_when(
      is.na(pop_served) ~ NA,
      pop_served > 100000 ~ "Very Large",
      pop_served > 10000 ~ "Large",
      pop_served > 3300 ~ "Medium",
      pop_served > 500 ~ "Small",
      pop_served <= 500 ~ "Very Small"))
``` 

## Drought vulnerability

DWR small system vulnerability data for validation, hosted on [this page](https://water.ca.gov/Programs/Water-Use-And-Efficiency/SB-552/SB-552-Tool) and downloaded as a csv from [this link](https://data.cnra.ca.gov/dataset/i07-water-shortage-vulnerability-small-water-systems).

More information on documentation and methodology is available [here](https://data.cnra.ca.gov/dataset/water-shortage-vulnerability-technical-methods/resource/090baaf3-dc47-4e21-8eba-d9bf499a76a0)
```{r}
dwr_vulnerability = read.csv("Data/Source/Small System Drought Vulnerability/i07_Water_Shortage_Vulnerability_Small_Water_Systems.csv")%>%
  select(SABL_PWSID, SC5e_Drought_Impact)%>%
  rename(pwsid = 1, drought_vulnerable = 2)%>%
  mutate(drought_vulnerable = ifelse(grepl("Listed as having", drought_vulnerable), 1, 0))
```

To get more commprehensive drought vulnerability data, we also add to this list a dataset of drought-vulnerable public water systems compiled by the Pacific Institute as part of [this](https://pacinst.org/wp-content/uploads/2017/01/PI_DroughtAndEquityInCA_Jan_2017.pdf) 2017 report. The data sources are also listed [here](https://pacinst.org/wp-content/uploads/2017/01/PI_DroughtAndEquityInCA-2017_Appendix1A_3.pdf). 
```{r}
pacific_vulnerability = read.csv("Data/Source/Small System Drought Vulnerability/Appendix-1B-Drought-Impacted-Public-Water-Systems.xlsx - DroughtImpactedPWS.csv")%>%
  rename(pwsid = PWSID)%>%
  select(pwsid)%>%
  filter(pwsid != "")%>%
  mutate(drought_vulnerable = 1, pacific_drought_vulnerable = 1)
```

Now we can combine the two. We'll consider a system drought vulnerable if it appears in any of the vulnerability datasets. 
```{r}
comb_vulnerability = bind_rows(dwr_vulnerability, pacific_vulnerability)%>%
  #filter(pwsid == "CA5610068")%>%
  group_by(pwsid)%>%
  reframe(
    drought_vulnerable = max(drought_vulnerable, na.rm = T),
    pacific_drought_vulnerable = max(pacific_drought_vulnerable, na.rm = T)) %>%
  ungroup() %>%
  mutate(across(c(drought_vulnerable, pacific_drought_vulnerable), 
                ~ ifelse(is.infinite(.), NA, .)))

rm(dwr_vulnerability, pacific_vulnerability)
```



# Calculating Metrics

## Centrality

Calculate in, out, and total degree centrality for systems. Compile into one 'master' dataframe with system centralities 
```{r}
system_centrality = all_nodes%>%
  filter(type == "system")%>%
  rename(in_degree = num_sw_sources,
         out_degree = num_systems_served,
         pwsid = id)%>%
  mutate(
    out_degree = replace_na(out_degree, 0),
    total_degree = in_degree + out_degree)%>%
  arrange(-total_degree)%>%
  select(pwsid, in_degree, out_degree, total_degree)
```

Calculate betweenness centrality - systems that are major redistribution hubs (ie: measure of centrality based on shortest paths that pass through a given node). Add to master dataframe.
```{r}
betweenness_all = betweenness(network, directed = TRUE)
system_centrality$betweenness = betweenness_all[V(network)$type == "system"]

rm(betweenness_all)
```

Out degree centrality for sources
```{r}
source_centrality = all_nodes%>%
  rename(source_name = id, out_degree = num_systems_served)%>%
  filter(type == "source")%>%
  arrange(-out_degree)%>%
  select(1:3)
```

## Path length

Calculate shortest paths from sources to systems
```{r}
sources = V(network)[type == "source"]
systems = V(network)[type == "system"]

# Get shortest paths between all sources to all systems
path_length_matrix = distances(network, v = sources, to = systems, mode = "out")
#path_lengths = as.vector(path_length_matrix[is.finite(as.vector(path_length_matrix))])

# Get shortest paths between all systems (for reachable systems calculation)
system_to_system_matrix = distances(network, v = systems, to = systems, mode = "out")
```

Summary stats for sources' path lengths
```{r}
source_path_lengths = data.frame(
  source_name = sources$name,
  n_reachable_systems = apply(path_length_matrix, 1, function(x) sum(is.finite(x))))
```

Summary stats for systems' path lengths

Right now, this is ONLY when systems are the final node on a path
```{r}
system_path_lengths = data.frame(
  pwsid = systems$name,
  mean_path_length = apply(path_length_matrix, 2, function(x) mean(x[is.finite(x)])),
  median_path_length = apply(path_length_matrix, 2, function(x) median(x[is.finite(x)])),
  max_path_length = apply(path_length_matrix, 2, function(x) max(x[is.finite(x)])),
  min_path_length = apply(path_length_matrix, 2, function(x) min(x[is.finite(x)])),
  n_reachable_sources = apply(path_length_matrix, 2, function(x) sum(is.finite(x))),
  n_reachable_systems = apply(system_to_system_matrix, 1, function(x) sum(is.finite(x)) - 1)) %>%  # Subtract 1 to exclude self
  arrange(-max_path_length)

rm(path_length_matrix, system_to_system_matrix)
```

## Source diversity

```{r}
# Calculate HHI for each system
system_diversity = sapply(systems, function(system) {
  # Get edges going into this system (sources supplying it)
  incoming_edges = E(network)[.to(system)]
  
  if (length(incoming_edges) == 0) return(NA)  # no sources
  
  # Get the usage percentages for this system's sources
  usage_percentages = incoming_edges$average_source_usage/100
  
  # Calculate HHI (sum of squares of market shares, scaled 0-10000)
  hhi = sum((usage_percentages * 100)^2)
  
  return(hhi)})

# Create a diversity data frame
diversity_df = data.frame(
  pwsid = systems$name,
  hhi = system_diversity,
  stringsAsFactors = FALSE,
  row.names = NULL)

rm(system_diversity, systems, sources)
```

Kristin also mentioned [participation coefficient](https://www.google.com/url?q=https://www.nature.com/articles/s41467-017-01189-w%23:~:text%3DParticipation%2520coefficient,-Given%2520a%2520particular%26text%3Dwhere%2520%257BK_i%257D%2520is%2520the%2520sum,are%2520to%2520a%2520single%2520community&sa=D&source=docs&ust=1762796373372331&usg=AOvVaw3DkgsUakhBdOK-fW7kOtPS). 

Seems like there are options to calculate it in R [example](https://search.r-project.org/CRAN/refmans/NetworkToolbox/html/participation.html)


## Local density / cluster / community
Kristin's hypothesis: on average, small systems will have less local density than large systems
How can we test?

## Bipartite project

Create one-mode projection on systems (systems connected if they share sources)
```{r, eval = F}
V(network)$type <- V(network)$type == "system"
system_adjacency = bipartite_projection(network)$proj1
```

# Combine all metrics into one dataframe

Join all system network metrics with system covariates. This can be used as the 'master file' for analysis.
```{r}
system_metrics_comb = left_join(system_centrality, system_path_lengths, by = "pwsid")%>%
  left_join(., diversity_df, by = "pwsid")%>%
  left_join(., all_nodes%>%
              filter(type == "system")%>%
              select(id, system_name:num_sw_sources, system_size)%>%
              rename(pwsid = id), 
            by = "pwsid")%>%
  left_join(., comb_vulnerability, by = "pwsid")%>%
  mutate(across(where(is.numeric), ~ replace_na(., 0)))
  
rm(diversity_df, system_centrality, system_path_lengths, comb_vulnerability)

table(system_metrics_comb$drought_vulnerable, useNA = "always")
```
Seems like among the small systems, we have 61 NAs where we can't find that system's PWSID in the DWR vulnerability data. Bring up with Kristin. 

Join all source network metrics as well
```{r}
source_metrics_comb = left_join(source_centrality, source_path_lengths, by = "source_name")
  
rm(source_centrality, source_path_lengths)
```


Code could potentially be split here so that we have one script that calculates network metrics and produces this master dataframe, which would be the input into a 2nd script focused on visualisations/analysis

# Descriptives of network dataset

```{r}
cat("Number of vertices:", vcount(network), "\n")
cat("Number of edges:", ecount(network), "\n")
cat("Network density:", round(edge_density(network), 4), "\n")

# Vertex counts by type
cat("Number of systems:", sum(V(network)$type == "system"), "\n")
cat("Number of sources:", sum(V(network)$type == "source"), "\n")

# Basic centrality measures
cat("Average degree:", round(mean(degree(network)), 2), "\n")
cat("Average betweenness:", round(mean(betweenness(network)), 2), "\n")
cat("Average closeness:", round(mean(closeness(network)), 4), "\n")
```

# System metrics

## Summary stats
System network metrics
Filter for very small/small/medium systems
```{r}
system_metrics_comb%>%
  filter(pop_served <= 10000)%>%
  select(in_degree, out_degree, betweenness, mean_path_length, hhi, n_reachable_sources, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))
```

Plots to visualise experience
```{r}
system_metrics_comb%>%filter(pop_served <= 10000)%>%
  select(in_degree:total_degree, betweenness)%>%
  pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
  ggplot(aes(value))+
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~variable, scales = "free")+
  labs(title = "System Centrality Metrics", x = "Value", y = "# of Systems") +
  theme_bw()

system_metrics_comb%>%filter(pop_served <= 10000)%>%
  select(mean_path_length:n_reachable_sources)%>%
  pivot_longer(everything(), names_to = "variable", values_to = "value")%>%
  ggplot(aes(value))+
  geom_histogram(binwidth = 1, fill = "steelblue", color = "black", alpha = 0.7) +
  facet_wrap(~variable, scales = "free")+
  labs(title = "System Path Lengths Metrics", x = "Value", y = "# of Systems") +
  theme_bw()

system_metrics_comb%>%filter(pop_served <= 10000)%>%
  ggplot(aes(hhi))+
  geom_histogram(fill = "steelblue", color = "black", alpha = 0.7) +
  labs(title = "System Source Diversity Metric", x = "Herfindahlâ€“Hirschman Index", y = "# of Systems") +
  theme_bw()
```

Let's make some quick scatter plots just to see the relationships between some of the system-level metrics we calculated
```{r}
ggpairs(system_metrics_comb[c(2:3, 5:6, 12)])+
  labs(title = "Scatterplot Matrix") +
  theme_bw()
```


## Differences by self-supplied

First, we generate a binary variable for self-supplied or not. We consider a system to be self-supplied if it purchases <50% of the water volume it receives.
```{r}
self_supplied = network_df%>%
  filter(purchased == 1)%>%
  group_by(pwsid)%>%
  reframe(percent_purchased = sum(average_source_usage))%>%
  ungroup()%>%
  mutate(self_supplied = ifelse(percent_purchased < 50, 1, 0))%>%
  select(-percent_purchased)

system_metrics_comb = system_metrics_comb%>%
  left_join(., self_supplied, by = "pwsid")%>%
  mutate(self_supplied = ifelse(is.na(self_supplied), 0, self_supplied))

table(system_metrics_comb$self_supplied)

rm(self_supplied)
```

Now, we can make a quick plot and statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.
```{r}
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), hhi))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "HHI")
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), in_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "In-Degree Centrality")
system_metrics_comb%>%
  ggplot(aes(as.factor(self_supplied), mean_path_length))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Self-Supplied", y = "Mean Path Length to Source")
```

```{r}
wilcox.test(hhi ~ self_supplied, data = system_metrics_comb)
aggregate(hhi ~ self_supplied, data = system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ self_supplied, data = system_metrics_comb)
aggregate(in_degree ~ self_supplied, data = system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ self_supplied, data = system_metrics_comb)
aggregate(mean_path_length ~ self_supplied, data = system_metrics_comb, FUN = mean)
```
These tests all come out significant: self-supplied systems tend to have lower HHI (ie: greater source diversity), higher in-degree centrality (ie: more sources), and greater path length (ie: further removed from their original sources). 





## Differences by drought impacted

Plots comparing distributions of vulnerability metrics by DWR drought vulnerability assessment
```{r}
system_metrics_comb%>%
  filter(!is.na(drought_vulnerable))%>%
  ggplot(aes(as.factor(drought_vulnerable), hhi))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "DWR Drought Vulnerability", y = "HHI")
system_metrics_comb%>%
  filter(!is.na(drought_vulnerable))%>%
  ggplot(aes(as.factor(drought_vulnerable), in_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "DWR Drought Vulnerability", y = "In-Degree Centrality")
system_metrics_comb%>%
  filter(!is.na(drought_vulnerable))%>%
  ggplot(aes(as.factor(drought_vulnerable), mean_path_length))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "DWR Drought Vulnerability", y = "Mean Path Length to Source")
```


Quick statistical test to see if distribution is different by group
Using mann-whitney test since data is non-parametric
```{r}
wilcox.test(hhi ~ drought_vulnerable, data = system_metrics_comb)
aggregate(hhi ~ drought_vulnerable, data = system_metrics_comb, FUN = mean)

wilcox.test(in_degree ~ drought_vulnerable, data = system_metrics_comb)
aggregate(in_degree ~ drought_vulnerable, data = system_metrics_comb, FUN = mean)

wilcox.test(mean_path_length ~ drought_vulnerable, data = system_metrics_comb)
aggregate(mean_path_length ~ drought_vulnerable, data = system_metrics_comb, FUN = mean)
```

Tests indicate that small systems designated as drought-vulnerable tend to have shorter path length (ie: less removed from their original sources) than non-drought-vulnerable systems. HHI and # of sources are not significant. 

## Differences by size

System in-degree centrality
Possible metric for systems' source redundancy (# of sources)
```{r}
system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(in_degree = mean(in_degree, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = in_degree, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean In-Degree Centrality")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(hhi = mean(hhi, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = hhi, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean HHI")+
  theme(legend.position = "none")

system_metrics_comb%>%
  filter(!is.na(system_size))%>%
  group_by(system_size)%>%
  reframe(mean_path_length = mean(mean_path_length, na.rm = T))%>%
  mutate(system_size = factor(system_size, levels = c("Very Small", "Small", "Medium", "Large", "Very Large")))%>%
  ggplot(aes(x = system_size, y = mean_path_length, fill = system_size))+
  geom_bar(stat = "identity")+
  theme_bw()+
  labs(x = "System Size", y = "Mean Path Length")+
  theme(legend.position = "none")
```

```{r}
summary(lm(hhi ~ pop_served, data = system_metrics_comb))
summary(lm(in_degree ~ pop_served, data = system_metrics_comb))
summary(lm(mean_path_length ~ pop_served, data = system_metrics_comb))
```

We generally see that as we go from very small to very large systems, in-degree centrality and mean path length increase, and HHI decreases, indicating that larger systems have more sources, greater source diversity, and are more removed from their original source. 
Based on a simple regression, these trends are statistically significant for HHI and in-degree.


# Source metrics

## Summary stats
```{r}
source_metrics_comb%>%
  select(out_degree, n_reachable_systems)%>%
  describe(quant = c(0.25, 0.75)) %>%
  as.data.frame()%>%
  rownames_to_column("variable")%>%
  select(-c(vars, sd, trimmed, mad, range:se))
```

## Differences by serving small vs large systems

First, let's determine the primary system size each source serves. We use the median population served to determine if large systems or small systems are the primary recipients. 

```{r}
system_size_served = network_df%>%
  group_by(source_name)%>%
  reframe(median_pop_served = median(pop_served, na.rm = T))%>%
  mutate(primary_system_size_served = ifelse(median_pop_served <= 10000, "Small", "Large"))

source_metrics_comb = source_metrics_comb%>%
  left_join(., system_size_served, by = "source_name")

table(source_metrics_comb$primary_system_size_served)

rm(system_size_served)
```
Now, we can make a quick plot and statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.
```{r}
source_metrics_comb%>%
  filter(!is.na(primary_system_size_served))%>%
  ggplot(aes(as.factor(primary_system_size_served), out_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Primary System Size Served", y = "Mean Out-Degree Centrality")
source_metrics_comb%>%
  filter(!is.na(primary_system_size_served))%>%
  ggplot(aes(as.factor(primary_system_size_served), n_reachable_systems))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Primary System Size Served", y = "Mean Number of Reachable Systems")
```

```{r}
wilcox.test(out_degree ~ primary_system_size_served, data = source_metrics_comb)
aggregate(out_degree ~ primary_system_size_served, data = source_metrics_comb, FUN = mean)

wilcox.test(n_reachable_systems ~ primary_system_size_served, data = source_metrics_comb)
aggregate(n_reachable_systems ~ primary_system_size_served, data = source_metrics_comb, FUN = mean)
```
Sources that primarily serve larger systems tend to have greater out-degree and number of reachable systems (ie: directly supply more systems and also indirectly reach more systems through the network)


## Differences by serving drought-impacted vs non-drought-impacted systems

First, we determine whether each source serves any drought-impacted system or not
```{r}
serve_drought_systems = network_df%>%
  left_join(., system_metrics_comb%>%select(pwsid, drought_vulnerable), by = "pwsid")%>%
  group_by(source_name)%>%
  reframe(drought_system_served = max(drought_vulnerable))
serve_drought_systems

source_metrics_comb = source_metrics_comb%>%
  left_join(., serve_drought_systems, by = "source_name")

table(source_metrics_comb$drought_system_served)

rm(serve_drought_systems)
```

Now, we can make a quick plot and statistical test to see to what extent our network metrics differ by self-supplied vs non-self-supplied systems.
```{r}
source_metrics_comb%>%
  ggplot(aes(as.factor(drought_system_served), out_degree))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Serves Drought-Impacted Systems", y = "Mean Out-Degree Centrality")
source_metrics_comb%>%
  ggplot(aes(as.factor(drought_system_served), n_reachable_systems))+
  geom_violin(fill = "coral1")+
  theme_bw()+
  labs(x = "Serves Drought-Impacted Systems", y = "Mean Number of Reachable Systems")
```

```{r}
wilcox.test(out_degree ~ drought_system_served, data = source_metrics_comb)
aggregate(out_degree ~ drought_system_served, data = source_metrics_comb, FUN = mean)

wilcox.test(n_reachable_systems ~ drought_system_served, data = source_metrics_comb)
aggregate(n_reachable_systems ~ drought_system_served, data = source_metrics_comb, FUN = mean)
```
Sources that serve a drought-impacted system tend to have greater number of reachable systems (ie: indirectly reach more systems through the network). Out-degree does not differ significantly by whether or not a source serves any drought-impacted systems.

# Community detection/clustering

```{r}
monopartite = graph_from_data_frame(network_df%>%rename(from = source_name, to = pwsid), directed = F)

louvain_comm <- cluster_louvain(monopartite)
membership_louvain <- membership(louvain_comm)
#modularity_louvain <- modularity(louvain_comm)

# Get basic statistics
num_communities <- length(unique(membership_louvain))
community_sizes <- sizes(louvain_comm)

# Create summary dataframe
data.frame(
  Community = 1:num_communities,
  size = as.numeric(community_sizes),
  stringsAsFactors = FALSE)
```
Hm, just creating 859 communities of size 2--not ideal. Perhaps this sort of community detection algorithm isn't the best option since our network is so sparse.

Either scrap or maybe instead do clustering based on types of roles within the network?


# Archive

Let's pull the worst-performing systems across various metrics
```{r}
#Systems with least source diversity
system_metrics_comb%>%
  arrange(-hhi)%>%
  head(10)

#Systems with longest average path length
system_metrics_comb%>%
  arrange(-mean_path_length)%>%
  head(10)

# Systems with just 1 source
system_metrics_comb%>%
  filter(in_degree == 1)
```
