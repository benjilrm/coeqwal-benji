
# Overview

The team has constructed a network dataset of California public water systems and the various sources they get their surface water from. 

In this script, we want add two groundwater-related variables to the dataset (for now in a separate table that we can join by PWSID). One being a simple binary just whether the PWS has groundwater or not, and the second being some indicator of if their groundwater meets drinking water standards.


# Set up

Import packages
```{r}
suppressPackageStartupMessages({
  suppressWarnings({
  library(tidyverse)   # Data wrangling
  library(here)        # File management
  library(readxl)      # Read excel files
  library(janitor)     # Clean up dataframe column names
  library(lubridate)   # Extract years from dates
  })})
```

Set settings and universal variables
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here())
```


# Import data

## Network data
Draft version of a network dataset of public water systems compiled by the team. 

```{r}
network_raw = read_excel("Data/Source/Network data/Falldata_boxworking_oct1.xlsx")
```

Note that the data is by source, so PWSIDs are repeated for as many water sources as the system has. 
Since we want the final output to just be a dataframe of the 2 groundwater variables by PWSID (which we can join back into the master dataframe by PWSIDlater once it's finalised), let's take a vector of the unique PWSIDs
```{r}
nrow(network_raw)
n_distinct(network_raw$PWSID)

network_pwsids = data.frame(pwsid = unique(network_raw$PWSID))

network_pwsids%>%
  filter(!grepl("CA", pwsid))
```
Although the dataset has 1111 rows, there are 861 unique PWSIDs, which we've now saved into a vector without duplicates. 

Note that there are 4 PWSs that aren't regulated any therefore do not have a 'normal' PWSID. Flagging as we will be assigning these values of NA for the groundwater variables.

## SAFER clearinghouse data
This is an internal state water board dataset they shared with us for this project. All documentation is located in [this Google Drive folder](https://drive.google.com/drive/folders/1gxMrGeaOA_xtGb1zf97Z79EFEwKcIpCG).

Unfortunately there is no data dictionary, but [Jenny has worked on developing one](https://docs.google.com/spreadsheets/d/1ulStajU7D1eFu2m3V0fTDtcm3PGNlneX/edit?gid=631545570#gid=631545570).

```{r}
# clearinghouse_raw = read_excel("Data/Source/SAFER clearinghouse/20250424_SAFER_CLEARINGHOUSE_EXPORT.xlsx", sheet = "SourceReporting")

#save(clearinghouse_raw, file = "Data/Source/SAFER clearinghouse/safer_clearinghouse.RData")
load("Data/Source/SAFER clearinghouse/safer_clearinghouse.RData")
```

Bring in another clearinghouse dataset with water system information so that we can filter for only facilities in community water systems. 
```{r}
# system_type_data = read_xlsx("Data/Source/SAFER clearinghouse/20250424_SAFER_CLEARINGHOUSE_EXPORT.xlsx", 
#                            sheet = "WaterSystemInformation")%>%
#   select(1, 3)%>%
#   rename(water_system_id = 1, state_water_system_type = 2)%>%
#   unique()

#save(system_type_data, file = "Data/Source/SAFER clearinghouse/clearinghouse_system_type_data.RData")
load("Data/Source/SAFER clearinghouse/clearinghouse_system_type_data.RData")

clearinghouse_joined = clearinghouse_raw%>%
  left_join(., system_type_data, by = "water_system_id")%>%
  filter(state_water_system_type == "COMMUNITY")%>%
  unique()

rm(system_type_data, clearinghouse_raw)
```

We want to filter for facilities with likely groundwater access. To do so, we will use the following filters:
- Only active facilities
- Exclude facilities serving as an emergency water source
- Filter out any sources that are explicitly surface water, in both the clearinghouse and SDWIS water type columns
- Filter out any springs, as these are considered surface water in our network dataset

We also compiled the remaining 55 facilities that included 'spring' in the facility name and manually went through to decide which to filter out. 
```{r}
clearinghouse_filtered = clearinghouse_joined%>%
  filter(facility_activity_status == "Active" & 
           sdwis_water_type != "Surface Water" & 
           !clearinghouse_water_type %in% c("Surface Water", "Spring Water") &
           facility_availability != "Emergency" &
           facility_type != "Spring")%>%
  mutate(index_facility_id = str_remove_all(index_facility_id, " "))%>%
  select(water_system_id, facility_name, facility_id, index_facility_id, facility_availability, facility_activity_status:clearinghouse_water_type)

manual_filter_out = c("CA1410500_001", "CA1410504_001", "CA1410507_001", "CA1410509_001", 
                                  "CA1710012_001", "CA1710012_004", "CA2801016_001", "CA2801016_002", 
                                  "CA2801016_003", "CA2801030_001", "CA3200175_005", "CA3310031_093", 
                                  "CA3600106_003", "CA3600205_001", "CA3600257_002", "CA3600262_001", 
                                  "CA3600262_004", "CA3600262_005", "CA5400511_001", "CA5400513_001", 
                                  "CA5400513_002", "CA5400728_001", "CA5400738_001", "CA5400783_001", 
                                  "CA5400826_001", "CA5400889_001", "CA5400916_001", "CA5400942_001", 
                                  "CA5400959_001", "CA5401089_001", "CA5401093_001", "CA5401093_002", 
                                  "CA5401093_003", "CA5403001_001", "CA5403020_001", "CA5500090_001", 
                                  "CA5500175_001", "CA5500248_001", "CA5500250_001")

clearinghouse_filtered_manual = clearinghouse_filtered %>%
  filter(!index_facility_id %in% manual_filter_out)

rm(clearinghouse_joined, clearinghouse_filtered)
```

We also are considering excluding consecutive connections from being considered groundwater access, so we will make a separate version with that scenario.
```{r}
clearinghouse_wo_consecutive_connections = clearinghouse_filtered_manual%>%
  filter(facility_type != "Consecutive Connection")
```

Diagnostics to send to Kristin for review, and flag any potential springs in community water systems. 
```{r, eval = F}
check = clearinghouse_filtered%>%
  filter(grepl("Spring", facility_name, ignore.case = T))%>%
  arrange(water_system_id, facility_id)%>%
  unique()

#write.csv(check, "Data/Outputs/20250902_facilities_to_check.csv", row.names = F)
```

## EDT

Drinking water quality data compiled by the State Water Resources Control Board and downloaded from [this page](https://www.waterboards.ca.gov/drinking_water/certlic/drinkingwater/EDTlibrary.html). Data dictionary is available [here](https://www.waterboards.ca.gov/drinking_water/certlic/drinkingwater/documents/edtlibrary/data_dictionary.pdf).

Similarly, with the EDT data we want to filter for MCL violations, in addition to the groundwater-related filters in the SAFER clearinghouse data. We will only consider violations in the most recent dataset, containing data from Jan 1, 2023 to Present (last updated August 19, 2025)

```{r}
#edt = read_delim("Data/Source/EDT Library/SDWIS4/SDWIS4.tab", delim = "\t", escape_double = FALSE, trim_ws = TRUE)%>%
  #clean_names()
#save(edt, file = "Data/Source/EDT Library/edt4.Rdata")
load("Data/Source/EDT Library/edt4.Rdata")
```

Filter for analyses with results in which the contaminant met or exceeded MCL levels
```{r}
edt_mcl = edt%>%
  filter(result >= mcl)%>%
  mutate(ps_code_clean = str_remove(ps_code, "_[^_]*$"), mcl_violation = 1)%>%
  select(ps_code_clean, mcl_violation)

rm(edt)
```



# Combining datasets

Join clearinghouse data with MCL violations and aggregate by PWSID. 

PWSIDs are determined to have groundwater compliant with drinking water standards if they have any groundwater sources without MCL violations. In other words, they are considered noncompliant only if 100% of groundwater sources have an MCL violation.
```{r}
clearinghouse_w_mcl_violations = left_join(clearinghouse_filtered_manual, edt_mcl, by = c("index_facility_id" = "ps_code_clean"))%>%
  mutate(gw_access_facility = 1,
         mcl_violation = replace_na(mcl_violation, 0))%>%
  group_by(water_system_id)%>%
  reframe(gw_access = max(gw_access_facility), 
          violation_rate = mean(mcl_violation, na.rm = T),
          gw_compliant_w_dw_standards = ifelse(violation_rate == 1, 0, 1))


clearinghouse_excl_consecutive_connections_w_mcl_violations = left_join(clearinghouse_wo_consecutive_connections, edt_mcl, by = c("index_facility_id" = "ps_code_clean"))%>%
  mutate(gw_access_facility = 1,
         mcl_violation = replace_na(mcl_violation, 0))%>%
  group_by(water_system_id)%>%
  reframe(gw_access = max(gw_access_facility), 
          violation_rate = mean(mcl_violation, na.rm = T),
          gw_compliant_w_dw_standards = ifelse(violation_rate == 1, 0, 1))
```
Now join with our original list of PWSIDs and add the new dummy columns, based on:
 - Whether or not PWS has at least 1 facility with groundwater access
 - Whether or not PWS has at least 1 groundwater facility compliant with drinking water standards (which we define as a facility without MCL violations)
```{r}
network_pwsids_w_gw_variables = network_pwsids%>%
  left_join(., clearinghouse_w_mcl_violations, by = c("pwsid" = "water_system_id"))%>%
  mutate(gw_access = case_when(
    !grepl("CA", pwsid) ~ NA,
    is.na(gw_access) ~ 0,
    T ~ gw_access))
```

Just to get a sense of the distribution of the violation rate across systems
```{r}
network_pwsids_w_gw_variables%>%
  ggplot(aes((violation_rate)*100))+
  geom_histogram(fill = "coral", col = "black")+
  theme_bw()+
  labs(x= "% of facilities in system with MCL violations", y = "# of systems")
```

Inspect to make sure everything looks okay
```{r}
table(network_pwsids_w_gw_variables$gw_access, useNA = "always")
table(network_pwsids_w_gw_variables$gw_compliant_w_dw_standards, useNA = "always")

addmargins(table(network_pwsids_w_gw_variables$gw_access, 
      network_pwsids_w_gw_variables$gw_compliant_w_dw_standards, 
      useNA = "always",
      dnn = c("GW Access", "GW Compliant with DW Standards")),
    margin = c(1, 2))
```
Version excluding consecutive connections
```{r}
network_pwsids_w_gw_variables_excl_consecutive_connections = network_pwsids%>%
  left_join(., clearinghouse_excl_consecutive_connections_w_mcl_violations, by = c("pwsid" = "water_system_id"))%>%
  mutate(gw_access = case_when(
    !grepl("CA", pwsid) ~ NA,
    is.na(gw_access) ~ 0,
    T ~ gw_access))

table(network_pwsids_w_gw_variables_excl_consecutive_connections$gw_access, useNA = "always")
table(network_pwsids_w_gw_variables_excl_consecutive_connections$gw_compliant_w_dw_standards, useNA = "always")

addmargins(table(network_pwsids_w_gw_variables_excl_consecutive_connections$gw_access, 
      network_pwsids_w_gw_variables_excl_consecutive_connections$gw_compliant_w_dw_standards, 
      useNA = "always",
      dnn = c("GW Access, excl. consecutive connections", "GW Compliant with DW Standards")),
      
     margin = c(1, 2))
```


Export 2 separate csvs
```{r}
write.csv(network_pwsids_w_gw_variables%>%select(-violation_rate), "Data/Outputs/20251002_network_pwsids_w_gw_variables.csv", row.names = F)

write.csv(network_pwsids_w_gw_variables_excl_consecutive_connections%>%select(-violation_rate), "Data/Outputs/20251002_network_pwsids_w_gw_variables_excl_consecutive_connections.csv", row.names = F)
```





